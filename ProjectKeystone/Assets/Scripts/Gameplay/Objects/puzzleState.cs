using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// A Gameplay Object Class that tracks the current state of puzzle in play.
/// </summary>
public class PuzzleState
{
    bool _isInPlay;
    public bool IsInPlay { get => _isInPlay; }
    int _matchPointGoalQuota;
    public int MatchPointGoalQuota { get => _matchPointGoalQuota; }
    float _timeLeft;
    float TimeLeft { get => _timeLeft; }
    int _tilePointScoreValue;
    PuzzleNextMatchQueue _puzzleNextMatchQueue;
    public PuzzleNextMatchQueue PuzzleNextMatchQueue { get => _puzzleNextMatchQueue; } 

    public List<PuzzlePlayer> puzzlePlayers;

    /// <summary>
    /// PuzzleState Constructor.
    /// </summary>
    /// <param name="numberOfPlayers">The number of active players for this puzzle.</param>
    /// <param name="matchClearScore">The number of matches required to clear this puzzle. Argument of 0 or less denotes Endless mode.</param>
    /// <param name="timeLimit">The initial time limit for this puzzle.</param>
    public PuzzleState(int numberOfPlayers, int matchClearScore, float timeLimit)
    {
        _isInPlay = true;
        _matchPointGoalQuota = matchClearScore;
        _timeLeft = timeLimit;
        //This will later be modified by difficulty
        _tilePointScoreValue = 100;
        //Current max planned players is 2, so capacity set to 2
        puzzlePlayers = new List<PuzzlePlayer>(2);
        for (int x = 0; x < numberOfPlayers; x++)
        {
            PuzzlePlayer newPlayer = new PuzzlePlayer();
            puzzlePlayers.Add(newPlayer);
        }
        _puzzleNextMatchQueue = new PuzzleNextMatchQueue();
    }

    /// <summary>
    /// Calculates the amount of score points generated by a successful match and subsequent clear.
    /// </summary>
    /// <param name="tilesCleared">The number of matchReady PuzzleTile objects to "clear."</param>
    /// <param name="comboCount">The player's current combo count.</param>
    /// <param name="keysUsedCount">The player's number of consecutive keys used in a combo.</param>
    /// <returns></returns>
    public int CalculateScorePoints(int tilesCleared, int comboCount, int keysUsedCount)
    {
        int result = 0;
        //Basic scor formula: 100t * n * m
        result = ((_tilePointScoreValue * tilesCleared) * comboCount) * keysUsedCount;
        return result;
    }

    /// <summary>
    /// Adjusts the score points of the specified player.
    /// </summary>
    /// <param name="player">The player's points to be adjusted.</param>
    /// <param name="amount">The amount of points (positive or negitive) to adjust a player's score points by.</param>
    public void AddScorePointsToPlayer(int player, int amount)
    {
        puzzlePlayers[player].AddScorePoint(amount);
    }

    /// <summary>
    /// Adjusts the remaining time limit for the current puzzle.
    /// </summary>
    /// <param name="amount"></param>
    public void AdjustTimeLeft(float amount)
    {
        _timeLeft += amount;
        CheckTimeOver();
    }

    /// <summary>
    /// Checks if the puzzle has run out of time, ending the game.
    /// </summary>
    private void CheckTimeOver()
    {
        if(_timeLeft <= 0)
        {
            //Time Up!
            _isInPlay = false;
            Debug.Log("Game Over! P1 Final Socre: " + puzzlePlayers[0].PlayerScorePoint.ToString());

        }
    }

    //
    //Difficulty modifiers:
    //Allowed MatchTypes
    //Allowed "Keys"
    ///"Key" Appearance weighting

}
